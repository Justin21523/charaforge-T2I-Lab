# core/t2i/watermark.py - Watermarking and attribution

from PIL import Image, ImageDraw, ImageFont, ImageEnhance
from typing import List, Optional, Dict, Any, Tuple
import io
import json
import hashlib
import numpy as np
from pathlib import Path

from core.config import get_cache_paths, get_model_path


class WatermarkManager:
    """Handles watermarking and attribution for generated images"""

    def __init__(self):
        self.cache_paths = get_cache_paths()
        self.default_font_size = 16
        self.watermark_templates = {
            "simple": "Generated by CharaForge",
            "detailed": "Generated by CharaForge T2I Lab - {timestamp}",
            "attribution": "CharaForge T2I | Model: {model} | Seed: {seed}",
            "copyright": "Â© CharaForge T2I Lab {year} - AI Generated",
        }

    def _get_font(self, size: int = None) -> ImageFont.FreeTypeFont:  # type: ignore
        """Get font for watermark text"""
        if size is None:
            size = self.default_font_size

        # Try to load system fonts
        font_paths = [
            "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf",  # Linux
            "/System/Library/Fonts/Arial.ttf",  # macOS
            "C:/Windows/Fonts/arial.ttf",  # Windows
            "/usr/share/fonts/TTF/arial.ttf",  # Arch Linux
        ]

        for font_path in font_paths:
            try:
                if Path(font_path).exists():
                    return ImageFont.truetype(font_path, size)
            except Exception:
                continue

        # Fallback to default font
        try:
            return ImageFont.load_default()  # type: ignore
        except Exception:
            return ImageFont.load_default()  # type: ignore

    def _calculate_text_position(
        self, image_size: Tuple[int, int], text_size: Tuple[int, int], position: str
    ) -> Tuple[int, int]:
        """Calculate text position on image"""
        img_width, img_height = image_size
        text_width, text_height = text_size

        margin = 10

        positions = {
            "bottom-right": (
                img_width - text_width - margin,
                img_height - text_height - margin,
            ),
            "bottom-left": (margin, img_height - text_height - margin),
            "top-right": (img_width - text_width - margin, margin),
            "top-left": (margin, margin),
            "center": ((img_width - text_width) // 2, (img_height - text_height) // 2),
            "bottom-center": (
                (img_width - text_width) // 2,
                img_height - text_height - margin,
            ),
            "top-center": ((img_width - text_width) // 2, margin),
        }

        return positions.get(position, positions["bottom-right"])

    def add_text_watermark(
        self,
        image: Image.Image,
        text: str = None,  # type: ignore
        template: str = "simple",
        position: str = "bottom-right",
        opacity: float = 0.7,
        font_size: int = None,  # type: ignore
        color: Tuple[int, int, int] = (255, 255, 255),
        shadow: bool = True,
        metadata: Dict[str, Any] = None,  # type: ignore
    ) -> Image.Image:
        """Add text watermark to image"""

        if text is None:
            # Use template
            text = self._format_watermark_text(template, metadata or {})

        # Create watermark overlay
        watermark = Image.new("RGBA", image.size, (0, 0, 0, 0))
        draw = ImageDraw.Draw(watermark)

        # Get font
        font = self._get_font(font_size or self.default_font_size)

        # Get text bounding box
        bbox = draw.textbbox((0, 0), text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]

        # Calculate position
        x, y = self._calculate_text_position(
            image.size, (text_width, text_height), position  # type: ignore
        )

        # Add shadow if requested
        if shadow:
            shadow_offset = 2
            shadow_color = (0, 0, 0, int(255 * opacity * 0.8))
            draw.text(
                (x + shadow_offset, y + shadow_offset),
                text,
                fill=shadow_color,
                font=font,
            )

        # Add main text
        text_color = (*color, int(255 * opacity))
        draw.text((x, y), text, fill=text_color, font=font)

        # Composite watermark onto image
        if image.mode != "RGBA":
            image = image.convert("RGBA")

        watermarked = Image.alpha_composite(image, watermark)

        # Convert back to RGB if needed
        if watermarked.mode == "RGBA":
            # Create white background for RGB conversion
            background = Image.new("RGB", watermarked.size, (255, 255, 255))
            background.paste(watermarked, mask=watermarked.split()[-1])
            watermarked = background

        return watermarked

    def _format_watermark_text(self, template: str, metadata: Dict[str, Any]) -> str:
        """Format watermark text with metadata"""
        if template not in self.watermark_templates:
            return template

        template_text = self.watermark_templates[template]

        # Default values
        format_dict = {
            "timestamp": metadata.get("timestamp", ""),
            "model": metadata.get("model", "SDXL"),
            "seed": metadata.get("seed", "unknown"),
            "year": "2024",
        }

        # Update with provided metadata
        format_dict.update(metadata)

        try:
            return template_text.format(**format_dict)
        except KeyError as e:
            print(f"[Watermark] Missing template key: {e}")
            return template_text

    def add_logo_watermark(
        self,
        image: Image.Image,
        logo_path: str = None,  # type: ignore
        position: str = "bottom-right",
        opacity: float = 0.7,
        scale: float = 0.1,
    ) -> Image.Image:
        """Add logo watermark to image"""

        if logo_path is None:
            # Create simple text logo
            return self.add_text_watermark(
                image, "CharaForge", position=position, opacity=opacity
            )

        logo_path = Path(logo_path)  # type: ignore
        if not logo_path.exists():  # type: ignore
            print(f"[Watermark] Logo not found: {logo_path}")
            return image

        try:
            # Load logo
            logo = Image.open(logo_path).convert("RGBA")

            # Scale logo
            max_size = int(min(image.size) * scale)
            logo.thumbnail((max_size, max_size), Image.Resampling.LANCZOS)

            # Adjust opacity
            if opacity < 1.0:
                # Create opacity mask
                alpha = logo.split()[-1]
                alpha = ImageEnhance.Brightness(alpha).enhance(opacity)
                logo.putalpha(alpha)

            # Calculate position
            margin = 10
            if position == "bottom-right":
                x = image.width - logo.width - margin
                y = image.height - logo.height - margin
            elif position == "bottom-left":
                x = margin
                y = image.height - logo.height - margin
            elif position == "top-right":
                x = image.width - logo.width - margin
                y = margin
            elif position == "top-left":
                x = margin
                y = margin
            else:
                x = image.width - logo.width - margin
                y = image.height - logo.height - margin

            # Paste logo
            if image.mode != "RGBA":
                image = image.convert("RGBA")

            image.paste(logo, (x, y), logo)

            # Convert back to RGB if needed
            if image.mode == "RGBA":
                background = Image.new("RGB", image.size, (255, 255, 255))
                background.paste(image, mask=image.split()[-1])
                image = background

            return image

        except Exception as e:
            print(f"[Watermark] Failed to add logo: {e}")
            return image

    def add_metadata_watermark(
        self, image: Image.Image, metadata: Dict[str, Any], method: str = "exif"
    ) -> Image.Image:
        """Add invisible metadata watermark"""

        if method == "exif":
            return self._add_exif_metadata(image, metadata)
        elif method == "steganography":
            return self._add_steganographic_watermark(image, metadata)
        else:
            print(f"[Watermark] Unknown metadata method: {method}")
            return image

    def _add_exif_metadata(
        self, image: Image.Image, metadata: Dict[str, Any]
    ) -> Image.Image:
        """Add metadata to EXIF data"""
        try:
            from PIL.ExifTags import TAGS

            # Convert metadata to EXIF format
            exif_dict = {}

            # Add common metadata fields
            if "prompt" in metadata:
                exif_dict["ImageDescription"] = metadata["prompt"][:255]  # EXIF limit

            if "software" not in metadata:
                metadata["software"] = "CharaForge T2I Lab"

            exif_dict["Software"] = metadata["software"]

            # Add generation parameters as comment
            generation_info = {
                "seed": metadata.get("seed"),
                "steps": metadata.get("steps"),
                "guidance_scale": metadata.get("guidance_scale"),
                "model": metadata.get("model"),
            }

            comment = json.dumps(generation_info, separators=(",", ":"))
            exif_dict["UserComment"] = comment.encode("utf-8")

            # Save with EXIF
            output = io.BytesIO()
            image.save(output, format="JPEG", exif=exif_dict)
            output.seek(0)

            return Image.open(output)

        except Exception as e:
            print(f"[Watermark] Failed to add EXIF metadata: {e}")
            return image

    def _add_steganographic_watermark(
        self, image: Image.Image, metadata: Dict[str, Any]
    ) -> Image.Image:
        """Add steganographic watermark using LSB"""
        try:
            # Convert metadata to string
            metadata_str = json.dumps(metadata, separators=(",", ":"))
            metadata_bytes = metadata_str.encode("utf-8")

            # Convert image to numpy array
            img_array = np.array(image)

            # Flatten array
            flat = img_array.flatten()

            # Add length prefix (4 bytes for length)
            length_bytes = len(metadata_bytes).to_bytes(4, byteorder="big")
            data_to_hide = length_bytes + metadata_bytes

            # Check if we have enough pixels
            if len(data_to_hide) * 8 > len(flat):
                print("[Watermark] Image too small for steganographic watermark")
                return image

            # Hide data in LSB
            bit_index = 0
            for byte in data_to_hide:
                for bit in range(8):
                    if bit_index >= len(flat):
                        break

                    # Get bit value
                    bit_val = (byte >> (7 - bit)) & 1

                    # Modify LSB
                    flat[bit_index] = (flat[bit_index] & 0xFE) | bit_val
                    bit_index += 1

            # Reshape back to original shape
            watermarked_array = flat.reshape(img_array.shape)

            return Image.fromarray(watermarked_array.astype(np.uint8))

        except Exception as e:
            print(f"[Watermark] Failed to add steganographic watermark: {e}")
            return image

    def extract_steganographic_watermark(
        self, image: Image.Image
    ) -> Optional[Dict[str, Any]]:
        """Extract steganographic watermark"""
        try:
            # Convert to numpy array
            img_array = np.array(image)
            flat = img_array.flatten()

            # Extract length (first 32 bits)
            length_bits = []
            for i in range(32):
                length_bits.append(flat[i] & 1)

            # Convert bits to length
            length_bytes = []
            for i in range(0, 32, 8):
                byte_val = 0
                for j in range(8):
                    byte_val = (byte_val << 1) | length_bits[i + j]
                length_bytes.append(byte_val)

            data_length = int.from_bytes(bytes(length_bytes), byteorder="big")

            if data_length > len(flat) // 8 - 4:
                return None  # Invalid length

            # Extract data
            data_bits = []
            for i in range(32, 32 + data_length * 8):
                data_bits.append(flat[i] & 1)

            # Convert bits to bytes
            data_bytes = []
            for i in range(0, len(data_bits), 8):
                byte_val = 0
                for j in range(8):
                    if i + j < len(data_bits):
                        byte_val = (byte_val << 1) | data_bits[i + j]
                data_bytes.append(byte_val)

            # Decode metadata
            metadata_str = bytes(data_bytes).decode("utf-8")
            return json.loads(metadata_str)

        except Exception as e:
            print(f"[Watermark] Failed to extract steganographic watermark: {e}")
            return None

    def create_attribution_image(
        self,
        original_image: Image.Image,
        metadata: Dict[str, Any],
        template: str = "detailed",
    ) -> Image.Image:
        """Create image with detailed attribution information"""

        # Create extended canvas
        padding = 60
        text_height = 120

        new_width = original_image.width + padding * 2
        new_height = original_image.height + text_height + padding * 2

        # Create new image with white background
        attributed = Image.new("RGB", (new_width, new_height), (255, 255, 255))

        # Paste original image
        attributed.paste(original_image, (padding, padding))

        # Add attribution text
        draw = ImageDraw.Draw(attributed)
        font_large = self._get_font(24)
        font_small = self._get_font(16)

        # Title
        title_y = original_image.height + padding + 10
        draw.text(
            (padding, title_y),
            "Generated by CharaForge T2I Lab",
            fill=(0, 0, 0),
            font=font_large,
        )

        # Details
        details_y = title_y + 35
        details = [
            f"Prompt: {metadata.get('prompt', 'N/A')[:80]}{'...' if len(metadata.get('prompt', '')) > 80 else ''}",
            f"Model: {metadata.get('model', 'Unknown')} | Seed: {metadata.get('seed', 'N/A')} | Steps: {metadata.get('steps', 'N/A')}",
            f"Size: {original_image.width}x{original_image.height} | Guidance: {metadata.get('guidance_scale', 'N/A')}",
        ]

        for i, detail in enumerate(details):
            draw.text(
                (padding, details_y + i * 20),
                detail,
                fill=(100, 100, 100),
                font=font_small,
            )

        return attributed
