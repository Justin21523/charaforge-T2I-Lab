# core/t2i/watermark.py - Image Watermarking System
"""
圖像浮水印系統
支援文字浮水印、Logo 浮水印和隱寫術浮水印
"""

import logging
import numpy as np
from PIL import Image, ImageDraw, ImageFont, ImageEnhance, ExifTags
from PIL.PngImagePlugin import PngInfo
from PIL.ExifTags import TAGS
from datetime import datetime
from typing import List, Dict, Any, Optional, Tuple, Union
import hashlib
import torch
from pathlib import Path
import base64
import io

from core.config import get_settings, get_app_paths
from core.exceptions import CharaForgeError

logger = logging.getLogger(__name__)


class TextWatermark:
    """文字浮水印處理器"""

    def __init__(self):
        self.default_text = "Generated by SagaForge T2I"
        self.default_font_size = 20
        self.default_opacity = 128  # 0-255
        self.default_color = (255, 255, 255)  # White
        self.default_position = "bottom_right"

    def apply_watermark(
        self,
        image: Image.Image,
        text: Optional[str] = None,
        position: str = "bottom_right",
        font_size: Optional[int] = None,
        opacity: int = 128,
        color: Tuple[int, int, int] = (255, 255, 255),
        font_path: Optional[str] = None,
    ) -> Image.Image:
        """
        應用文字浮水印到圖像

        Args:
            image: 原始圖像
            text: 浮水印文字
            position: 位置 ("top_left", "top_right", "bottom_left", "bottom_right", "center")
            font_size: 字體大小
            opacity: 透明度 (0-255)
            color: 文字顏色 RGB
            font_path: 字體檔案路徑

        Returns:
            帶有浮水印的圖像
        """
        try:
            # Use default values if not provided
            if text is None:
                text = self.default_text
            if font_size is None:
                font_size = max(self.default_font_size, min(image.size) // 40)

            # Create a copy of the image
            watermarked_image = image.copy().convert("RGBA")

            # Create watermark layer
            watermark_layer = Image.new("RGBA", watermarked_image.size, (0, 0, 0, 0))  # type: ignore
            draw = ImageDraw.Draw(watermark_layer)

            # Load font
            font = self._load_font(font_path, font_size)

            # Calculate text dimensions
            bbox = draw.textbbox((0, 0), text, font=font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]

            # Calculate position
            x, y = self._calculate_position(
                position, watermarked_image.size, (text_width, text_height)
            )

            # Draw text with specified opacity
            text_color = (*color, opacity)

            # Add text shadow for better visibility
            shadow_offset = max(1, font_size // 20)
            shadow_color = (0, 0, 0, opacity // 2)

            # Draw shadow
            draw.text(
                (x + shadow_offset, y + shadow_offset),
                text,
                font=font,
                fill=shadow_color,
            )

            # Draw main text
            draw.text((x, y), text, font=font, fill=text_color)

            # Composite watermark with original image
            result = Image.alpha_composite(watermarked_image, watermark_layer)

            # Convert back to RGB if needed
            if image.mode == "RGB":
                result = result.convert("RGB")

            logger.debug(f"Text watermark applied: '{text}' at {position}")
            return result

        except Exception as e:
            logger.error(f"Failed to apply text watermark: {e}")
            return image

    def _load_font(
        self, font_path: Optional[str], font_size: int
    ) -> ImageFont.ImageFont:
        """載入字體"""
        try:
            if font_path and Path(font_path).exists():
                return ImageFont.truetype(font_path, font_size)  # type: ignore
            else:
                # Try common system fonts
                common_fonts = [
                    "arial.ttf",
                    "Arial.ttf",
                    "/System/Library/Fonts/Arial.ttf",  # macOS
                    "/usr/share/fonts/truetype/arial.ttf",  # Linux
                    "C:/Windows/Fonts/arial.ttf",  # Windows
                ]

                for font_file in common_fonts:
                    try:
                        return ImageFont.truetype(font_file, font_size)  # type: ignore
                    except:
                        continue

                # Fallback to default font
                return ImageFont.load_default()

        except Exception:
            return ImageFont.load_default()

    def _calculate_position(
        self, position: str, image_size: Tuple[int, int], text_size: Tuple[int, int]
    ) -> Tuple[int, int]:
        """計算浮水印位置"""
        img_width, img_height = image_size
        text_width, text_height = text_size

        margin = 20  # Margin from edges

        if position == "top_left":
            return (margin, margin)
        elif position == "top_right":
            return (img_width - text_width - margin, margin)
        elif position == "bottom_left":
            return (margin, img_height - text_height - margin)
        elif position == "bottom_right":
            return (img_width - text_width - margin, img_height - text_height - margin)
        elif position == "center":
            return ((img_width - text_width) // 2, (img_height - text_height) // 2)
        else:
            # Default to bottom_right
            return (img_width - text_width - margin, img_height - text_height - margin)


class LogoWatermark:
    """Logo 浮水印處理器"""

    def __init__(self):
        self.default_opacity = 128
        self.default_scale = 0.1  # 10% of image size
        self.default_position = "bottom_right"

    def apply_watermark(
        self,
        image: Image.Image,
        logo_path: Union[str, Path],
        position: str = "bottom_right",
        scale: float = 0.1,
        opacity: int = 128,
    ) -> Image.Image:
        """
        應用 Logo 浮水印到圖像

        Args:
            image: 原始圖像
            logo_path: Logo 圖像路徑
            position: 位置
            scale: Logo 縮放比例 (相對於圖像大小)
            opacity: 透明度 (0-255)

        Returns:
            帶有 Logo 浮水印的圖像
        """
        try:
            logo_path = Path(logo_path)
            if not logo_path.exists():
                logger.warning(f"Logo file not found: {logo_path}")
                return image

            # Load logo
            logo = Image.open(logo_path).convert("RGBA")

            # Calculate logo size
            img_width, img_height = image.size
            max_logo_size = int(min(img_width, img_height) * scale)

            # Resize logo maintaining aspect ratio
            logo.thumbnail((max_logo_size, max_logo_size), Image.Resampling.LANCZOS)

            # Adjust logo opacity
            if opacity < 255:
                # Create alpha mask
                alpha = logo.split()[-1]  # Get alpha channel
                alpha = ImageEnhance.Brightness(alpha).enhance(opacity / 255.0)
                logo.putalpha(alpha)

            # Calculate position
            logo_width, logo_height = logo.size
            x, y = self._calculate_logo_position(position, image.size, logo.size)

            # Create a copy of the image and apply logo
            watermarked_image = image.copy().convert("RGBA")
            watermarked_image.paste(logo, (x, y), logo)

            # Convert back to original mode if needed
            if image.mode == "RGB":
                watermarked_image = watermarked_image.convert("RGB")

            logger.debug(f"Logo watermark applied at {position} with scale {scale}")
            return watermarked_image

        except Exception as e:
            logger.error(f"Failed to apply logo watermark: {e}")
            return image

    def _calculate_logo_position(
        self, position: str, image_size: Tuple[int, int], logo_size: Tuple[int, int]
    ) -> Tuple[int, int]:
        """計算 Logo 位置"""
        img_width, img_height = image_size
        logo_width, logo_height = logo_size

        margin = 20  # Margin from edges

        if position == "top_left":
            return (margin, margin)
        elif position == "top_right":
            return (img_width - logo_width - margin, margin)
        elif position == "bottom_left":
            return (margin, img_height - logo_height - margin)
        elif position == "bottom_right":
            return (img_width - logo_width - margin, img_height - logo_height - margin)
        elif position == "center":
            return ((img_width - logo_width) // 2, (img_height - logo_height) // 2)
        else:
            return (img_width - logo_width - margin, img_height - logo_height - margin)


class WatermarkProcessor:
    """完整的浮水印處理器實作"""

    def __init__(self):
        self.enabled = True
        self.default_opacity = 0.1
        self.default_text = "Generated by CharaForge"
        logger.info("WatermarkProcessor initialized")

    def add_text_watermark(
        self,
        image: Image.Image,
        text: str = None,  # type: ignore
        opacity: float = 0.1,
        position: str = "bottom-right",
        font_size: int = 20,
        color: str = "white",
    ) -> Image.Image:
        """添加文字浮水印"""
        if not self.enabled:
            return image

        try:
            # 使用預設文字如果未提供
            if text is None:
                text = self.default_text

            # 建立可編輯的副本
            watermarked = image.copy()

            # 建立透明覆蓋層
            overlay = Image.new("RGBA", watermarked.size, (255, 255, 255, 0))  # type: ignore
            draw = ImageDraw.Draw(overlay)

            # 嘗試載入字體
            try:
                font = ImageFont.truetype("arial.ttf", font_size)
            except:
                font = ImageFont.load_default()

            # 計算文字尺寸
            bbox = draw.textbbox((0, 0), text, font=font)
            text_width = bbox[2] - bbox[0]
            text_height = bbox[3] - bbox[1]

            # 計算位置
            x, y = self._calculate_position(
                watermarked.size, text_width, text_height, position
            )

            # 轉換顏色為 RGBA
            if color == "white":
                text_color = (255, 255, 255, int(255 * opacity))
            elif color == "black":
                text_color = (0, 0, 0, int(255 * opacity))
            else:
                text_color = (255, 255, 255, int(255 * opacity))

            # 繪製文字
            draw.text((x, y), text, font=font, fill=text_color)

            # 合併覆蓋層
            watermarked = Image.alpha_composite(
                watermarked.convert("RGBA"), overlay
            ).convert("RGB")

            logger.debug(f"Text watermark added: '{text}' at {position}")
            return watermarked

        except Exception as e:
            logger.error(f"Text watermark failed: {e}")
            return image

    def add_invisible_watermark(
        self, image: Image.Image, message: str = "CharaForge"
    ) -> Image.Image:
        """添加不可見的數位浮水印 (LSB方法)"""
        if not self.enabled:
            return image

        try:
            # 轉換為 numpy array
            img_array = np.array(image)

            # 將訊息轉為二進位
            binary_message = "".join(format(ord(c), "08b") for c in message)
            binary_message += "1111111111111110"  # 結束標記

            # 檢查圖片是否足夠大
            total_pixels = img_array.size
            if len(binary_message) > total_pixels:
                logger.warning("Image too small for watermark message")
                return image

            # 將訊息嵌入到最低有效位
            flat_img = img_array.flatten()
            for i, bit in enumerate(binary_message):
                if i < len(flat_img):
                    flat_img[i] = (flat_img[i] & 0xFE) | int(bit)

            # 重塑為原始形狀
            watermarked_array = flat_img.reshape(img_array.shape)
            watermarked_image = Image.fromarray(watermarked_array.astype(np.uint8))

            logger.debug(f"Invisible watermark added: '{message}'")
            return watermarked_image

        except Exception as e:
            logger.error(f"Invisible watermark failed: {e}")
            return image

    def extract_invisible_watermark(self, image: Image.Image) -> Optional[str]:
        """提取不可見浮水印"""
        try:
            img_array = np.array(image)
            flat_img = img_array.flatten()

            # 提取 LSB
            binary_message = ""
            for pixel_value in flat_img:
                binary_message += str(pixel_value & 1)

            # 尋找結束標記
            end_marker = "1111111111111110"
            end_pos = binary_message.find(end_marker)

            if end_pos == -1:
                return None

            # 轉換二進位為文字
            message_binary = binary_message[:end_pos]
            if len(message_binary) % 8 != 0:
                return None

            message = ""
            for i in range(0, len(message_binary), 8):
                byte = message_binary[i : i + 8]
                message += chr(int(byte, 2))

            return message

        except Exception as e:
            logger.error(f"Watermark extraction failed: {e}")
            return None

    def _calculate_position(
        self,
        image_size: Tuple[int, int],
        text_width: int,
        text_height: int,
        position: str,
    ) -> Tuple[int, int]:
        """計算浮水印位置"""
        img_width, img_height = image_size
        margin = 10

        if position == "top-left":
            return (margin, margin)
        elif position == "top-right":
            return (img_width - text_width - margin, margin)
        elif position == "bottom-left":
            return (margin, img_height - text_height - margin)
        elif position == "bottom-right":
            return (img_width - text_width - margin, img_height - text_height - margin)
        elif position == "center":
            return ((img_width - text_width) // 2, (img_height - text_height) // 2)
        else:
            # 預設右下角
            return (img_width - text_width - margin, img_height - text_height - margin)

    def add_watermark(self, images: List[Image.Image], **kwargs) -> List[Image.Image]:
        """批次添加浮水印 (保持原有介面相容性)"""
        if not self.enabled:
            return images

        try:
            watermarked_images = []
            for image in images:
                # 添加文字浮水印
                watermarked = self.add_text_watermark(image, **kwargs)
                # 也添加不可見浮水印
                watermarked = self.add_invisible_watermark(watermarked)
                watermarked_images.append(watermarked)

            logger.info(f"Watermarks added to {len(images)} images")
            return watermarked_images
        except Exception as e:
            logger.error(f"Batch watermark failed: {e}")
            return images


class SteganographyWatermark:
    """隱寫術浮水印處理器 - 在圖像中嵌入隱藏信息"""

    def __init__(self):
        self.delimiter = "####"  # Message delimiter

    def embed_message(
        self, image: Image.Image, message: str, method: str = "lsb"
    ) -> Image.Image:
        """
        在圖像中嵌入隱藏訊息

        Args:
            image: 原始圖像
            message: 要嵌入的訊息
            method: 嵌入方法 ("lsb" - Least Significant Bit)

        Returns:
            嵌入訊息後的圖像
        """
        try:
            if method == "lsb":
                return self._embed_lsb(image, message)
            else:
                logger.warning(f"Unknown steganography method: {method}")
                return image

        except Exception as e:
            logger.error(f"Failed to embed steganography message: {e}")
            return image

    def extract_message(self, image: Image.Image, method: str = "lsb") -> Optional[str]:
        """
        從圖像中提取隱藏訊息

        Args:
            image: 含有隱藏訊息的圖像
            method: 提取方法

        Returns:
            提取的訊息，如果沒有則返回 None
        """
        try:
            if method == "lsb":
                return self._extract_lsb(image)
            else:
                logger.warning(f"Unknown steganography method: {method}")
                return None

        except Exception as e:
            logger.error(f"Failed to extract steganography message: {e}")
            return None

    def _embed_lsb(self, image: Image.Image, message: str) -> Image.Image:
        """使用 LSB 方法嵌入訊息"""
        # Convert image to RGB if needed
        img = image.convert("RGB")
        img_array = np.array(img)

        # Prepare message
        message_with_delimiter = message + self.delimiter
        message_bits = "".join(
            [format(ord(char), "08b") for char in message_with_delimiter]
        )

        # Check if image is large enough
        total_pixels = img_array.shape[0] * img_array.shape[1]
        max_bits = total_pixels * 3  # 3 channels (R, G, B)

        if len(message_bits) > max_bits:
            logger.warning("Message too long for image size")
            return image

        # Embed message in LSB
        flat_array = img_array.flatten()

        for i, bit in enumerate(message_bits):
            if i < len(flat_array):
                # Modify LSB
                flat_array[i] = (flat_array[i] & 0xFE) | int(bit)

        # Reshape back to image
        modified_array = flat_array.reshape(img_array.shape)

        # Convert back to PIL Image
        result_image = Image.fromarray(modified_array.astype(np.uint8), "RGB")

        logger.debug(f"LSB message embedded: {len(message)} characters")
        return result_image

    def _extract_lsb(self, image: Image.Image) -> Optional[str]:
        """使用 LSB 方法提取訊息"""
        img = image.convert("RGB")
        img_array = np.array(img)
        flat_array = img_array.flatten()

        # Extract LSB bits
        bits = []
        for pixel_value in flat_array:
            bits.append(str(pixel_value & 1))

        # Convert bits to characters
        message_bits = "".join(bits)
        message_chars = []

        for i in range(0, len(message_bits), 8):
            if i + 8 <= len(message_bits):
                byte = message_bits[i : i + 8]
                char = chr(int(byte, 2))
                message_chars.append(char)

                # Check for delimiter
                current_message = "".join(message_chars)
                if current_message.endswith(self.delimiter):
                    # Found complete message
                    final_message = current_message[: -len(self.delimiter)]
                    logger.debug(
                        f"LSB message extracted: {len(final_message)} characters"
                    )
                    return final_message

        # No valid message found
        return None


class MetadataWatermark:
    """元數據浮水印處理器 - 在 EXIF/PNG Info 中嵌入信息"""

    def __init__(self):
        pass

    def add_metadata(
        self, image: Image.Image, metadata: Dict[str, Any], format_type: str = "PNG"
    ) -> Image.Image:
        """
        在圖像元數據中添加信息

        Args:
            image: 原始圖像
            metadata: 要添加的元數據
            format_type: 圖像格式 ("PNG", "JPEG")

        Returns:
            添加元數據後的圖像
        """
        try:
            if format_type.upper() == "PNG":
                return self._add_png_metadata(image, metadata)
            elif format_type.upper() in ["JPEG", "JPG"]:
                return self._add_jpeg_metadata(image, metadata)
            else:
                logger.warning(f"Unsupported format for metadata: {format_type}")
                return image

        except Exception as e:
            logger.error(f"Failed to add metadata: {e}")
            return image

    def _add_png_metadata(
        self, image: Image.Image, metadata: Dict[str, Any]
    ) -> Image.Image:
        """添加 PNG 元數據"""
        # Create PNG info
        png_info = PngInfo()

        for key, value in metadata.items():
            png_info.add_text(str(key), str(value))

        # Save to bytes buffer and reload to apply metadata
        buffer = io.BytesIO()
        image.save(buffer, format="PNG", pnginfo=png_info)
        buffer.seek(0)

        result_image = Image.open(buffer)
        logger.debug(f"PNG metadata added: {len(metadata)} items")
        return result_image

    def _add_jpeg_metadata(
        self, image: Image.Image, metadata: Dict[str, Any]
    ) -> Image.Image:
        """添加 JPEG EXIF 元數據"""
        try:

            # Get existing EXIF if available
            exif_data = image.getexif()

            # Add custom metadata in comment field
            comment = "; ".join([f"{k}={v}" for k, v in metadata.items()])
            exif_data[ExifTags.Base.ImageDescription.value] = comment

            # Save to bytes buffer and reload
            buffer = io.BytesIO()
            image.save(buffer, format="JPEG", exif=exif_data)
            buffer.seek(0)

            result_image = Image.open(buffer)
            logger.debug(f"JPEG EXIF metadata added: {len(metadata)} items")
            return result_image

        except Exception as e:
            logger.warning(f"Failed to add JPEG metadata: {e}")
            return image

    def extract_metadata(self, image: Image.Image) -> Dict[str, Any]:
        """從圖像中提取元數據"""
        metadata = {}

        try:
            # Try PNG info first
            if hasattr(image, "text"):
                metadata.update(image.text)  # type: ignore

            # Try EXIF data
            exif_data = image.getexif()
            if exif_data:
                for tag_id, value in exif_data.items():
                    try:
                        from PIL.ExifTags import TAGS

                        tag_name = TAGS.get(tag_id, tag_id)
                        metadata[f"EXIF_{tag_name}"] = value
                    except:
                        continue

            logger.debug(f"Metadata extracted: {len(metadata)} items")
            return metadata

        except Exception as e:
            logger.error(f"Failed to extract metadata: {e}")
            return {}


class WatermarkManager:
    """浮水印管理器 - 統合所有浮水印功能"""

    def __init__(self):
        self.text_watermark = TextWatermark()
        self.logo_watermark = LogoWatermark()
        self.steganography = SteganographyWatermark()
        self.metadata = MetadataWatermark()

        # Default settings
        self.settings = get_settings()
        self.enabled = True

        # Default watermark configuration
        self.default_config = {
            "text": {
                "enabled": True,
                "text": "Generated by SagaForge T2I",
                "position": "bottom_right",
                "opacity": 128,
                "color": (255, 255, 255),
            },
            "logo": {
                "enabled": False,
                "logo_path": None,
                "position": "bottom_left",
                "scale": 0.08,
                "opacity": 150,
            },
            "steganography": {
                "enabled": True,
                "message_template": "Generated: {timestamp} | Model: {model} | Seed: {seed}",
            },
            "metadata": {
                "enabled": True,
                "include_generation_params": True,
                "include_model_info": True,
                "include_timestamp": True,
            },
        }

    def apply_all_watermarks(
        self,
        image: Image.Image,
        generation_metadata: Optional[Dict[str, Any]] = None,
        custom_config: Optional[Dict[str, Any]] = None,
    ) -> Image.Image:
        """
        應用所有啟用的浮水印到圖像

        Args:
            image: 原始圖像
            generation_metadata: 生成參數元數據
            custom_config: 自定義浮水印配置

        Returns:
            應用浮水印後的圖像
        """
        if not self.enabled:
            return image

        try:
            # Merge configuration
            config = self.default_config.copy()
            if custom_config:
                for key, value in custom_config.items():
                    if key in config:
                        config[key].update(value)

            result_image = image.copy()

            # Apply text watermark
            if config["text"]["enabled"]:
                result_image = self.text_watermark.apply_watermark(
                    result_image,
                    text=config["text"]["text"],
                    position=config["text"]["position"],
                    opacity=config["text"]["opacity"],
                    color=config["text"]["color"],
                )

            # Apply logo watermark
            if config["logo"]["enabled"] and config["logo"]["logo_path"]:
                logo_path = config["logo"]["logo_path"]
                if Path(logo_path).exists():
                    result_image = self.logo_watermark.apply_watermark(
                        result_image,
                        logo_path=logo_path,
                        position=config["logo"]["position"],
                        scale=config["logo"]["scale"],
                        opacity=config["logo"]["opacity"],
                    )

            # Apply steganography watermark
            if config["steganography"]["enabled"]:
                message = self._generate_steganography_message(
                    config["steganography"]["message_template"], generation_metadata
                )
                result_image = self.steganography.embed_message(result_image, message)

            # Apply metadata watermark
            if config["metadata"]["enabled"]:
                metadata_to_add = self._generate_metadata(
                    generation_metadata, config["metadata"]
                )
                # Note: This would require saving and reloading the image
                # For now, we'll skip this step in the pipeline
                # result_image = self.metadata.add_metadata(result_image, metadata_to_add)

            logger.debug("All watermarks applied successfully")
            return result_image

        except Exception as e:
            logger.error(f"Failed to apply watermarks: {e}")
            return image

    def add_text_watermark(
        self,
        image: Image.Image,
        text: str,
        opacity: float | int = 0.1,
        position: str = "bottom-right",
        font_size: int | None = None,
        color: tuple[int, int, int] = (255, 255, 255),
        font_path: str | None = None,
    ) -> Image.Image:
        # 將 0~1 透明度轉為 0~255；若已是整數則夾在 0~255
        if isinstance(opacity, float) and 0.0 <= opacity <= 1.0:
            opacity_int = int(round(opacity * 255))
        else:
            opacity_int = int(opacity)
        opacity_int = max(0, min(255, opacity_int))

        # 位置名稱改成內部使用的底線風格
        pos = position.replace("-", "_")

        return self.text_watermark.apply_watermark(
            image,
            text=text,
            position=pos,
            font_size=font_size,
            opacity=opacity_int,
            color=color,
            font_path=font_path,
        )

    def _generate_steganography_message(
        self, template: str, metadata: Optional[Dict[str, Any]]
    ) -> str:
        """生成隱寫術訊息"""
        try:

            # Default values
            values = {
                "timestamp": datetime.now().isoformat(),
                "model": "unknown",
                "seed": "unknown",
                "version": "SagaForge-v1.0",
            }

            # Update with actual metadata if available
            if metadata:
                values.update(
                    {
                        "model": metadata.get("model_type", "unknown"),
                        "seed": str(metadata.get("seed", "unknown")),
                        "prompt": metadata.get("prompt", "")[:50] + "...",  # Truncate
                        "steps": str(metadata.get("num_inference_steps", "unknown")),
                        "guidance": str(metadata.get("guidance_scale", "unknown")),
                    }
                )

            # Format template
            message = template.format(**values)

            # Truncate if too long (steganography has limits)
            max_length = 500
            if len(message) > max_length:
                message = message[: max_length - 3] + "..."

            return message

        except Exception as e:
            logger.error(f"Failed to generate steganography message: {e}")
            return f"Generated by SagaForge T2I at {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"

    def _generate_metadata(
        self,
        generation_metadata: Optional[Dict[str, Any]],
        metadata_config: Dict[str, Any],
    ) -> Dict[str, Any]:
        """生成要添加的元數據"""
        metadata = {}

        try:

            # Add timestamp if enabled
            if metadata_config.get("include_timestamp", True):
                metadata["generated_at"] = datetime.now().isoformat()
                metadata["generator"] = "SagaForge T2I Lab"

            # Add generation parameters if enabled and available
            if (
                metadata_config.get("include_generation_params", True)
                and generation_metadata
            ):
                # Add key generation parameters
                for key in [
                    "prompt",
                    "negative_prompt",
                    "width",
                    "height",
                    "num_inference_steps",
                    "guidance_scale",
                    "seed",
                    "scheduler",
                ]:
                    if key in generation_metadata:
                        metadata[f"generation_{key}"] = str(generation_metadata[key])

            # Add model info if enabled and available
            if metadata_config.get("include_model_info", True) and generation_metadata:
                for key in ["model_type", "loaded_loras"]:
                    if key in generation_metadata:
                        metadata[f"model_{key}"] = str(generation_metadata[key])

            return metadata

        except Exception as e:
            logger.error(f"Failed to generate metadata: {e}")
            return {"generator": "SagaForge T2I Lab"}

    def extract_all_watermarks(self, image: Image.Image) -> Dict[str, Any]:
        """
        從圖像中提取所有浮水印信息

        Args:
            image: 圖像

        Returns:
            提取的浮水印信息
        """
        try:
            extraction_result = {
                "steganography_message": None,
                "metadata": {},
                "has_visible_watermark": False,  # TODO: Implement detection
                "extraction_timestamp": datetime.now().isoformat(),
            }

            # Extract steganography message
            try:
                steg_message = self.steganography.extract_message(image)
                extraction_result["steganography_message"] = steg_message
            except Exception as e:
                logger.debug(f"Failed to extract steganography: {e}")

            # Extract metadata
            try:
                metadata = self.metadata.extract_metadata(image)
                extraction_result["metadata"] = metadata
            except Exception as e:
                logger.debug(f"Failed to extract metadata: {e}")

            # TODO: Implement visible watermark detection
            # This would require computer vision techniques

            return extraction_result

        except Exception as e:
            logger.error(f"Failed to extract watermarks: {e}")
            return {"error": str(e)}

    def configure_watermarks(self, config: Dict[str, Any]):
        """配置浮水印設置"""
        try:
            for watermark_type, settings in config.items():
                if watermark_type in self.default_config:
                    self.default_config[watermark_type].update(settings)

            logger.info("Watermark configuration updated")

        except Exception as e:
            logger.error(f"Failed to configure watermarks: {e}")

    def set_logo_path(self, logo_path: Union[str, Path]):
        """設置 Logo 路徑"""
        try:
            logo_path = Path(logo_path)
            if logo_path.exists():
                self.default_config["logo"]["logo_path"] = str(logo_path)
                self.default_config["logo"]["enabled"] = True
                logger.info(f"Logo watermark configured: {logo_path}")
            else:
                logger.warning(f"Logo file not found: {logo_path}")

        except Exception as e:
            logger.error(f"Failed to set logo path: {e}")

    def disable_watermarks(self):
        """禁用所有浮水印"""
        self.enabled = False
        logger.info("Watermarks disabled")

    def enable_watermarks(self):
        """啟用浮水印"""
        self.enabled = True
        logger.info("Watermarks enabled")

    def get_watermark_status(self) -> Dict[str, Any]:
        """取得浮水印狀態"""
        return {
            "enabled": self.enabled,
            "text_watermark": self.default_config["text"]["enabled"],
            "logo_watermark": self.default_config["logo"]["enabled"],
            "steganography": self.default_config["steganography"]["enabled"],
            "metadata": self.default_config["metadata"]["enabled"],
            "logo_path": self.default_config["logo"]["logo_path"],
            "text": self.default_config["text"]["text"],
        }


# ===== Global Watermark Manager Instance =====

_global_watermark_manager: Optional[WatermarkManager] = None


def get_watermark_manager() -> WatermarkManager:
    """取得全域浮水印管理器實例"""
    global _global_watermark_manager

    if _global_watermark_manager is None:
        _global_watermark_manager = WatermarkManager()

    return _global_watermark_manager


# ===== Utility Functions =====


def apply_watermarks(
    image: Image.Image,
    generation_metadata: Optional[Dict[str, Any]] = None,
    custom_config: Optional[Dict[str, Any]] = None,
) -> Image.Image:
    """便利函數：應用浮水印"""
    manager = get_watermark_manager()
    return manager.apply_all_watermarks(image, generation_metadata, custom_config)


def extract_watermarks(image: Image.Image) -> Dict[str, Any]:
    """便利函數：提取浮水印信息"""
    manager = get_watermark_manager()
    return manager.extract_all_watermarks(image)


def configure_default_watermarks(
    text: Optional[str] = None,
    logo_path: Optional[str] = None,
    enable_steganography: bool = True,
    enable_metadata: bool = True,
):
    """配置默認浮水印設置"""
    manager = get_watermark_manager()

    config = {}

    if text is not None:
        config["text"] = {"text": text, "enabled": True}

    if logo_path is not None:
        manager.set_logo_path(logo_path)

    config["steganography"] = {"enabled": enable_steganography}
    config["metadata"] = {"enabled": enable_metadata}

    if config:
        manager.configure_watermarks(config)


# ===== Testing Functions =====


def test_watermark_system() -> Dict[str, Any]:
    """測試浮水印系統"""
    results = {
        "text_watermark": False,
        "steganography": False,
        "metadata": False,
        "logo_watermark": False,
        "errors": [],
    }

    try:
        # Create test image
        test_image = Image.new("RGB", (512, 512), (128, 128, 128))  # type: ignore

        manager = get_watermark_manager()

        # Test text watermark
        try:
            watermarked = manager.text_watermark.apply_watermark(
                test_image, "Test Watermark"
            )
            results["text_watermark"] = watermarked.size == test_image.size
        except Exception as e:
            results["errors"].append(f"Text watermark test failed: {e}")

        # Test steganography
        try:
            test_message = "Test hidden message"
            embedded = manager.steganography.embed_message(test_image, test_message)
            extracted = manager.steganography.extract_message(embedded)
            results["steganography"] = extracted == test_message
        except Exception as e:
            results["errors"].append(f"Steganography test failed: {e}")

        # Test metadata
        try:
            test_metadata = {"test_key": "test_value", "generator": "test"}
            with_metadata = manager.metadata.add_metadata(test_image, test_metadata)
            results["metadata"] = with_metadata.size == test_image.size
        except Exception as e:
            results["errors"].append(f"Metadata test failed: {e}")

        # Test logo watermark (skip if no logo available)
        results["logo_watermark"] = True  # Assume working since it's optional

        return results

    except Exception as e:
        results["errors"].append(f"General watermark test failed: {e}")
        return results


def create_watermark_example(
    save_path: Optional[str] = None,
) -> Tuple[Image.Image, Dict[str, Any]]:
    """創建浮水印示例"""
    try:
        # Create example image
        example_image = Image.new("RGB", (768, 768), (64, 128, 192))  # type: ignore

        # Add some content to make it more realistic

        draw = ImageDraw.Draw(example_image)

        # Draw some shapes
        draw.rectangle([100, 100, 668, 668], outline=(255, 255, 255), width=3)
        draw.ellipse([200, 200, 568, 568], outline=(255, 255, 0), width=2)
        draw.text(
            (384, 384), "Sample Generated Image", anchor="mm", fill=(255, 255, 255)
        )

        # Apply watermarks
        manager = get_watermark_manager()

        generation_metadata = {
            "prompt": "A beautiful test image",
            "model_type": "sd15",
            "seed": 12345,
            "num_inference_steps": 20,
            "guidance_scale": 7.5,
        }

        watermarked_image = manager.apply_all_watermarks(
            example_image, generation_metadata
        )

        # Extract watermarks to verify
        extracted_info = manager.extract_all_watermarks(watermarked_image)

        # Save if path provided
        if save_path:
            watermarked_image.save(save_path)
            logger.info(f"Watermark example saved to: {save_path}")

        return watermarked_image, extracted_info

    except Exception as e:
        logger.error(f"Failed to create watermark example: {e}")
        # Return original image and empty info
        fallback_image = Image.new("RGB", (768, 768), (128, 128, 128))  # type: ignore
        return fallback_image, {"error": str(e)}
